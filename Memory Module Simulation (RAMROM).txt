//Memory Module Simulation (RAM/ROM)
//code 
`timescale 1ns/1ps
module memory_module (
    input clk,
    input rst,
    input we,              // Write Enable
    input [3:0] addr,      // 4-bit Address (16 locations)
    input [7:0] din,       // 8-bit Data input
    output reg [7:0] dout  // 8-bit Data output
);

    reg [7:0] ram [15:0]; // 16 x 8-bit RAM

    // Write operation (synchronous)
    always @(posedge clk or posedge rst) begin
        if (rst) begin
            // Optionally clear RAM (or just dout)
            dout <= 8'b0;
        end else if (we) begin
            ram[addr] <= din;  // Write to RAM
        end
    end

    // Read operation (combinational)
    always @(*) begin
        if (!we)
            dout = ram[addr]; // Output current address
        else
            dout = din;       // During write, show input
    end

endmodule


//testbench
`timescale 1ns/1ps
module tb_memory_module;

    reg clk;
    reg rst;
    reg we;
    reg [3:0] addr;
    reg [7:0] din;
    wire [7:0] dout;

    // Instantiate RAM
    memory_module uut (
        .clk(clk),
        .rst(rst),
        .we(we),
        .addr(addr),
        .din(din),
        .dout(dout)
    );

    // Clock generation
    initial clk = 0;
    always #5 clk = ~clk; // 10ns period

    initial begin
        // Reset
        rst = 1; we = 0; addr = 0; din = 0;
        #10 rst = 0;

        // Write data
        we = 1; addr = 4'b0001; din = 8'hAA; #10;
        addr = 4'b0010; din = 8'h55; #10;
        addr = 4'b0011; din = 8'hFF; #10;

        // Read data
        we = 0; addr = 4'b0001; #10;
        addr = 4'b0010; #10;
        addr = 4'b0011; #10;

        $finish;
    end

    // Monitor signals
    initial begin
        $monitor("Time=%0t | WE=%b | ADDR=%b | DIN=%h | DOUT=%h", $time, we, addr, din, dout);
    end

endmodule
